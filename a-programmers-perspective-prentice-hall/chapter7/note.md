## 为什么要理解链接?

- 理解链接器将更加容易构造大型程序
- 理解连接器可以避免一些错误
- **理解链接器可以理解语言的的作用于规则是如何实现的**
- **理解链接器可以理解系统的一些重要的概念**
- 理解链接器使你能够利用共享库


## 编译驱动程序

使用```gcc -Og -o prog main.c sum.c```编译程序

```
    main.c                  sum.c        源代码
      |                      |
   翻译器,cpp,cll,as     翻译器,cpp,cll,as
      |                      |
    main.o                  sum.o        可重定位目标文件
      |                      |
	  |_______链接器LD_______|
	             |
				prog  完全可执行的目标
```
1. `cpp [other arg] main.c /tmp/main.i`.这一步将源码变成ASCII中间文件
2. `ccl /tmp/main.i -Og [other arg] -o /tmp/main.s`.这一步编译出汇编源文件
3. `as [other arg] -o /tmp/main.o /tmp/main.s`  这一步搞出可重定位目标文件
4. `ld -o prog [other arg]` /tmp/main.o /tmp/sum.o 这一步高出可执行目标文件
这里会出现一些错误,必须要手动链接`libc.so`. 可是**我不会啊...**



## 静态链接
像Linux LD程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入,生成一个完全链接的,可以加载和运行的可执行文件作为输出.为了构造可执行文件,链接器必须完成两个任务
- 符号解析: 目标文件定义和引用符号,每个符号对应于一个函数,一个全局变量和一个静态变量.符号解析的目的是将每个符号引用正好和一个符号定义关联起来
- 重定位: 编译器和汇编器生成从地址0开始的代码和数据节.链接器通过把每个符号定义为一个内存位置关联起来,从而重定位这些节,然后修改所有对这些符号的引用,使得他们指向这个内存位置.链接器使用汇编器产生的重定位条目的详细指令.不加甄别的执行这样的重定位

## 目标文件
目标文件有三种形式
- 可重定位目标文件: 包含二进制代码和数据,其形式可以再编译时与其他可重定位的目标文件合并起来,创建一个可执行目标文件
- 可执行目标文件: 包含二进制代码和数据,其形式可以直接复制到内存并执行
- 共享目标文件: 一种特殊类型的可重定位目标文件,可以再加载或者运行时被动态的加载进内存并链接

## 可重定位目标文件
`ELF`(Executable and Linkable Format).
```
 ___________________________0__
|         ELF头            |   |
|--------------------------|   |
|        .text             |   |
|--------------------------|   |
|        .rodata           |   |
|--------------------------|   |
|        .data             |   |
|--------------------------|   |
|        .bss              |   |
|--------------------------|   |
|        .symtab           |  节
|--------------------------|   |
|        .rel .text        |   |
|--------------------------|   |
|        .rel .data        |   |
|--------------------------|   |
|        .debug            |   |
|--------------------------|   |
|        .line             |   |
|--------------------------|   |
|        .strtab           |   |
|--------------------------| 描述
|        节头部表          | 目标
|__________________________|文件的节
```
- .text: 已编译程序的机器代码
- .rodata: 只读数据,比如printf语句中的格式串和开关语句的跳转表
- .data: 已初始化的全局和静态C变量.局部C变量在运行时被保存在栈中,不出现在.data节中,也不出现在.bss节中
- .bss: 未初始化的全局和静态C变量,以及所有被初始化为0的全局或静态变量.在目标文件中这个节不占据实际的空间,他仅仅只是一个占位符.目标文件格式区分已初始化和未初始化变量是为了空间效率
- .symtab: 一个符号表,他存放在程序中定义和引用的函数和全局变量的信息.
- .rel .text: 一个.text节中位置的列表.当链接器把这个目标文件和其他文件组合时,需要修改这些位置.
- .rel .data: 被模块引用或定义的所有全局变量的重定位信息.
- .debug: 一个调试符号表,条目式程序中定义的局部变量和类型定义,成功需中定义和引用的全局变量.以及原始的C源文件.
- .line: 原始C源程序中的行号和.text节中机器指令之间的映射
- .strtab: 一个字符串表,其内容包括.symtab和.debug节中的符号表.以及节头部中街节名字.


## 符号和符号表
每个可重定位目标模块m都有一个符号表,它包含M定义和引用的符号的信息.在链接器的上下文中,有三种不同的符号:
- 由模块M定义并能被其他模块引用的全局符号.全局链接器符号对应于非静态C函数和全局变量
- 由其他模块定义并被模块m引用的全局符号,这些符号被称之为外部符号,对应于其他模块的定义的非静态C函数和全局变量
- 只被模块m定义和引用的局部符号.它们对应于带static属性的C函数和全局变量.这些符号在模块m中的任何位置都可见,但是不能被其他模块引用
认识到本地链接器符号和本地程序变量不同是非常重要的. .symtab中的符号表不包含对应于本地非静态程序变量的任何符号.这些符号在运行时在栈中被管理.符号根本不敢兴趣.


## 符号解析

### 链接器如何解析多重定义的全局符号
全局符号分为强和弱,比如
```
/* foo1.c */
int main()
{
		return 0;
}

/* bar1.c */
int main()
{
		return 0;
}
linux > gcc foo1.c bar1.c
/tmp/cc5kGGIR.o：在函数‘main’中：
bar1.c:(.text+0x0): multiple definition of `main'
/tmp/ccNctMlP.o:foo1.c:(.text+0x0)：第一次在此定义
collect2: 错误：ld 返回 1
```


### 与静态库链接
如果不使用静态库,编译器开发人员会使用什么方法来向用户提供这些预定义豪的函数.一种方法是让编译器辨认出对标准函数的调用.并直接生成相应的代码.但是这种方法对C是不合适的.因为C标准定义了大量的标准函数.
```gcc main.c /user/lib/libc.o```
将所有的C函数都放在一个单独的可重定位目标模块中.这个方法的有点事将编译器的实现和标准函数实现分离开来.但是有一个不好的地方就是浪费空间.另外一个大的缺点是,对任何标准函数的任何改变,无论多么小的改变,都要求库的开发人员重新编译整个源文件.这是一个非常耗时的操作.

```gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ...```
我们可以为每个标准函数创建一个独立的可重定位文件,把它们存放在一个大家都知道的目录来解决这个问题.然而,这种方法要求应用程序员显示的链接合适的目标模块到它们的可执行文件中.这是一个容易出错而且耗时的过程:
所以静态库的概念被提出来了.以解决这些不同方法的缺点.相关的函数可以被编译为独立的目标模块,然后封装成一个单独的静态库文件.然后应用程序可以通过在命令行制定单独的文件名字来使用这些在库中定义的函数,比如,使用C标准库和数学库中函数的程序可以用形式一下的命令行来编译和链接:
```gcc main.c /usr/lib.libm.a /usr/lib/libc.a```
在链接的时候,链接器支付至被程序引用的目标模块.这就减少了可执行文件在磁盘和内存中的大小.另一方面,应用程序员只要包含较少的库文件的名字.实际上C编译器驱动程序总是传送libc.a给链接器.
在linux系统中,静态库以一种称为存档的特殊文件格式存放在磁盘中, 存档文件是一组连接起来的可重定位目标文件的集合.有一个头部来描述每个成员目标文件的大小和位置.存档文件由后缀.a标识.
来,我们自己搞一个静态库.
```
gcc -c addvec.c multvec.c
ar rcs libvector.a addvec.o multvec.
gcc -c main2.c
gcc -static -o prog2c main2.o ./libvector.a
# 或者 -L.参数告诉链接器在当前目录查找libvector.a
gcc -static -o prog2c main2.o -L. -lvector
```

```
     main2.c                     vector.h
	   |                            |
   翻译器(cpp,cc1, as)	        libvector.a           libc.a     静态库
       |                            |                   |
	 main2.o                      addvec.o           printf.o和其他调用printf.o调用的模块
	   |____________________________|___________________|
	                            |链接器(ld)|
								------------
								    |
								  prog2c  完全连接的可执行目标文件
		
```


### 链接器如何使用静态库来解析引用

