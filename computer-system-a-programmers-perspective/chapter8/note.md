作为程序员,理解ECF(Exception Control Flow)概念有以下帮助
- 协助理解重要的系统概念,操作系统实现I/O,进程,虚拟内存的基本机制是ECF
- 理解ECF将帮组你理解应用程序如何与操作系统进行交互
- 理解ECF将帮组你实现有趣的程序,比如shell和web
- 理解ECF将帮助你理解并发

## 异常
异常是异常控制流的一种形式,一部分由硬件组成,一部分由软件组成
```
-----------------------------------------------------------------
| 类别 |  原因                | 同步 |     返回行为             |
-----------------------------------------------------------------
| 中断 |  来时I/O设备的异常   | 异步 |   总是返回下一条指令     |
-----------------------------------------------------------------
| 陷阱 |  有异的异常          | 同步 |   总是返回下一条指令     |
-----------------------------------------------------------------
| 故障 |  潜在可恢复的异常    | 同步 |   可能返回当前指令       |
-----------------------------------------------------------------
| 终止 |  不可恢复的异常      | 同步 |   不会返回               |
-----------------------------------------------------------------
```

### 中断
中断事由一步发生的是来自外处理器外部的IO设备的信号的结果硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是一部的硬件终端的异常处理程序，常常称为中断处理程序.在当前指令完成执行之后，处理器注意到中断，引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序，当处理程序，返回时，它就会将控制返回给下一条指令，业绩如果没有发生中断，在异常控制流中会将当前指令之后的那条指令，结果是程序继续执行，就好像没有发生过中断一样剩下的异常类型陷阱故障和中指都是同步发生的，是执行当前指令的，结果我们把这类指令叫做故障指令

### 陷阱和系统调用
陷阱是有意的异常是执行一条指令的结果就像中断处理程序一样，限制数据程序将控制返回到下一条指令陷阱，最重要的用途是在用户程序和用户之间提供一个项目过程一样的接口就是系统调用，用户程序经常需要向内核请求服务，比如读一个文件创建一个进程，加载一个新的城市，不终止当前进程，为了允许对这些类和服务受控的访问，出去提供一条特殊的system call指令当用户想要请求服务时，可以执行这条指令执行申购会导致一个到一场处理程序的陷阱.这个处理程序解析参数并调用适当的内核程序，从程序员的角度来看，系统调用和普通的函数调用是一样的，然后他们的实现非常不同，普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而他们只能访问与调用函数相同的站系统调用运行在内核模式中，内核模式允许系统调用执行特权指令并访问定义在内核中的战

### 故障
故障是由错误情况引起的，他可能能够被故障处理程序修正，当工厂发生时，处理器将控制转移给故障处理程序，如果处理程序能够纠正这种错误情况，它就将控制返回到引起故障的指令，从而重新开始执行它，否则处理程序将返回内核的历程会终止引起故障的应用程序

### 终止
终止时不可恢复错误造成的结果,通常是硬件错误


## 进程
异常是允许操作系统内核提供进程(process)概念的基本构造块.在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样，我们的程序好像独占的使用了内存，所以就好像无间断的一条接一条的执行或我们程序中的指令.
- 一个独立的逻辑控制流,它提供一个假象,好像我们的程序独占使用处理器
- 一个私有的地址空间,他提供一个假象,好像我们的程序独占使用内存系统


### 逻辑控制流
### 并发流
计算机系统逻辑流有许多不同的形式。异常处理程序，进程，信号处理程序，线程和Java进程都是逻辑流的例子。



### 私有地址空间

进程也为每个程序提供一个假象，好像它独占使用系统地址空间。在一个N位地址的机器上，地址空间是2^n个可能地址的集合。

```
      ----------------------------------------
      |       内存虚拟内存                   |
      |   （代码，数据，堆，栈               |  ⬆用户代码不可见的内存
2^48-1----------------------------------------
      |       用户栈                         |
	  |     （运行时创建的）                 | <- %esp(栈指针)
	  ----------------------------------------
	  |          ⬇                           |          
	  |          ⬆                           |
	  ----------------------------------------
	  |      共享库的内存映射区域            |
	  ----------------------------------------
	  |          ⬆                           |
	  ---------------------------------------- <- brc
	  |       运行时堆                       |
	  |     (用malloc创建的)                 |
	  ---------------------------------------- -----
	  |        读/写 段                      |     |
	  |      （.data, .bss)                  |     | 
	  ----------------------------------------     |->从可执行文件加载 
	  |        只读代码段                    |     |
	  | (.int, .text. rodata)                |     |
	  ---------------------------------------- -----  <- 0x00400000
	  |                                      |
	 -----------------------------------------  0 
```


### 用户模式和内核模式
操作系统过通过寄存器某个模式位来表示当前处以何种模式
运行应用程序代码的井成初始时实在用户模式中的，进程从用户模式变为内核模式的唯一方法是通过诸如终端，故障或者陷入系统调用这种的异常。
当异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它范围到应用程序代码时。处理九八模式从内核模式改为
到用户模式。
linux提供一个聪明的机制，叫做/proc文件系统，它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个
用户程序可以读的文本文件的层次结构

### 上下文切换
操作系统内核使用一种称为上下文切换的较高层次形式的异常控制流来实现多任务。这个机制时间里较低层异常机制之上。内核为每一个进程维持
一个上下文。
什么是上下文？ 上下文就是内核重新启动一个被抢占的进程所需的状态，它有一些对象的值组成。这些对象包括寄存器，用户栈，内核栈，内核数据结构。
比如描述地址空间的页表，当前进程信息的进程表，已打开文件的信息的文件表。内核中有一个`scheduler`的代码处理的。


## 进程控制

### 获取进程id
```
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```

### 创建和终止进程
从程序员理解来说， 我们可以认为进程总是处以下面三种状态之一：
- 运行： 要不然就在CPU上执行，要不然就是等待执行，且它最后肯定会被调度
- 停止： 进程的执行被suspended，且不会被调度。当收到SIGSTOP,SIGTSTP,SIGTTIN或者SIGTTOU信号时，进程就停止，
并且保持停止直到它受到一个SIGCONT信号，在这个时刻，进程再次开始执行。
- 终止： 进程永远的停止了
Fork函数,查看fork.c
- Fork函执行一次，返回两次
- 并发执行
- 相同但是独立的地址空间
- 共享文件

### 回收子进程
进程终止之后,内核并不是立即把它从系统中清楚.等待父进程回收.一个终止了但还未被回收的
进程称为(zombie)



### 让进程休眠
```
#include <unistd.h>

unsigned int sleep(unsigned int secs);
```

### 加载并运行程序
```
#include <unistd.h>

int execve(const char *filename, const char *argv[], const char *envp[])
```

```
#include <stdlib.h>

char *getenv(const char *name);

int setenv(const char *name, const char *newvalue, int overwrite);
void unsetenv(const char *name);
```

>>> what's difference between program and process. 
程序是一堆代码和数据,程序可以作为目标文件存在于磁盘上,或者作为段存在地址空间中.进程是
执行中程序的一个具体的实例;程序重视运行在某个进程的上下文的.如果你要理解`fork`和`execve`函数,理解这个差异很重要.`fork`函数在新的进程中运行相同的程序,新的子进程是父进程的一个
复制品.`execve`函数在当前进程的上下文中加载并运行一个新的程序.它会覆盖当前进程的地址空间,但没有创建于给新进程.新的程序仍然有相同的PID.并且继承调用Execve函数已经带开了的文家描述符.


### 利用fork和execve运行程序


## 信号
信号是一个更高层次的异常.它允许进程和内核中断其他进程, 每个信号类型都对应某种系统事件. 信号提供了一种机制,通知用户进程发生了这些异常.比如一个程序试图处以0,那么内核就发送给他
一个SIGFPE.



### 发送信号
每个进程都一个进程租,默认属于父进程的. 通过
```
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);

```

### 用alarm函数发送信号
进程可以通过调用alarm函数向它自己发送SIGALRM信号.
```
#include <unistd.h>

unsigned int alarm(unsigned int secs);
```


### 接受信号
每个信号有一个预定义行为:
- 进程中止
- 进程终止并转储内存
- 进程停止(挂起)直到被SIGCONT信号重启
- 进程忽略该信号


### 阻塞和解除阻塞信
Linux提供阻塞信号的隐式和显式的机制:
隐式阻塞机制: 内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号,假设程序捕获了信号s,当前正在运行处理程序S,如果发送给该进程另一个信号s,那么
直到处理程序S返回,s会变成待处理而没有接收.
显示阻塞机制: 应用程序可以使用sigprocmask函数和它的辅助函数,明确地阻塞和解除阻塞选定的信号
#### 安全信号处理
信号处理程序很麻烦是因为它们和主程序以及其他信号处理程序并发地运行,如果处理程序和主程序并发地访问同样的全局数据结构,那么结果可能就不可预知,而且经常
是致命地
-处理程序要简单
-处理程序中调用异步信号安全地函数.异步信号安全地函数有两种. 可重入,就是址访问局部变量要不然就是不能被信号处理程序中断
-保存和恢复errno
-素色所有地信号,保护对共享全局数据结构地访问
- 用volatile声明全局变量, 避免编译器优化
- 用sig_atomic_t生命标志

#### 正确地处理信号
信号是不排队地,如果存在一个未处理地型号表示至少拥有一个信号到达了,看下面这个成许`signal1.c`.基本结构是父进程创建一些子进程.这些子进程各自独立运行一段时间.然后终止,父进程必须回收紫禁城一般避免在系统中留下僵尸进程.但是我们还是希望赴京城能够在紫禁城运行时自由地去做其他地哦给你做,所有我们决定用SIGCHLD处理程序来回收紫荆城.只有一个子进程终止或者停止,内核就会发送一个SIGCHLD信号给父进程.

### 非本地跳转
C语言提供了一种用户级异常控制流形式,称之为非本地跳转.他将控制直接从要给函数转移到另外一个当前正在执行的呃函数.而不需要经过正常的调用返回序列.
非本地跳转通过`setjmp`和`longjmp`函数来提供
```
#include <setjmp.h>

int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);

void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);

```
非本地跳转一个最重要的作用就是允许从要给深层嵌套的函数调用中立即返回.
